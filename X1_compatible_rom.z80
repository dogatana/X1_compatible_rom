;
; X1 compatible IPL
;
; programed by NAKAUE,T
;
; These codes are licensed under CC0.
; http://creativecommons.org/publicdomain/zero/1.0/deed.ja
;
; 2020-07-31 ver0.1.0 first version
;                     武田君のエミュレータでS-OS SWORDを起動できた
;                     バイナリサイズ 950byte，未実装機能があるのに大きい
; 2020-08-01 ver0.2.0 リファクタリング
;                     ディスク関係以外のアドレスをオリジナルと合わせた
;                     連続空きメモリ134バイト
;
; かつて X1エミュの部屋(http://www.turboz.to/)に掲載されていた
; ぷにゅ氏作の IPL ver1.01(x1ipl101.zip,IPLROM.z80)を参考にしている
;
; その他の参考文献
; X1 turbo  BIOSの解析,稲葉 康治,Oh!MZ 1985年1月号,p.97～109
; IOCS DATA LIST,泉 大介ら,Oh!MZ 1986年11月号,p.76～
; 試験に出るX1,祝 一平，日本ソフトバンク,1987
; HuBASIC Format詳細,BouKiCHi,https://boukichi.github.io/HuDisk/HuBASIC_Format.html
;   2020-07-31 閲覧

; FDD0-3からの起動のみ実装する
; CMT，Timer関係を実装しない
; ROMとEMMの実装を保留

; 以下のエントリを固定番地とする
; 0066h : NMIリセット(ok)
; 00f5h : IPLエラー処理?(未実装)
; (01cfh : IPL overlay?) 詳細不明なので無視
; 021ah : IPL用ディスクREAD
; 038ah : IPL用KEY入力(ok)
; 03cbh : IPL用メッセージ表示(ok)
; 03d9h : IPL用1文字表示ルーチン(ok)
;
; 以下のバッファを固定番地とする
; 0ff80h : カーソルxy
; 0ff86h : テキスト色
; 0ff87h : ドライブ番号

; ワークエリアアドレス

WRKTOP  equ     0ff80h                  ; ワークエリアの先頭アドレス
TXTCUR  equ     WRKTOP + 0h
TXTATR  equ     WRKTOP + 6h
IPLDRV  equ     WRKTOP + 7h
WRKSIZ  equ     10h                     ; ワークエリアの長さ

FILEBUF equ     0de00h                  ; ファイル読込みバッファ


; 以下はturbo BIOSで使用
COLORF  equ     0f8d0h
CLSCHR  equ     0f8d1h

; IOアドレス
IOFDCCR equ     0ff8h                   ; FDC コマンドレジスタ
IOFDCTR equ     0ff9h                   ; FDC トラックレジスタ
IOFDCSR equ     0ffah                   ; FDC セクタレジスタ
IOFDCDR equ     0ffbh                   ; FDC データレジスタ
IOFDCNO equ     0ffch                   ; ドライブNo./サイド/モーターON
IOCRTC  equ     1800h                   ; CRTC レジスタ
IO80C49 equ     1900h                   ; サブCPU
IO8255B equ     1a01h                   ; 8255 port B
IO8255C equ     1a02h                   ; 8255 port C
IOIPLOF equ     1e00h                   ; IPL ROM OFF
IOATTR  equ     2000h                   ; アトリビュートVRAM
IOTEXT  equ     3000h                   ; テキストVRAM
TXTSIZ  equ     800h                    ; テキストVRAMのサイズ

; IOATTRとIOTEXTで異なるビット位置
; log2((IOATTR ^ IOTEXT) >> 8)
BIT_ATTR_TEXT   equ     4

; テキストクリアの標準色
TEXT_STD        equ     2007h           ; 20=SPC,07=白


        org     00000h

; ----------------------------------------------------------
; メインルーチンとメニュー
; ----------------------------------------------------------

; IPL起動
IPLBOT:

        ; ワークエリアの初期化 (インライン展開済み)
        ; 12バイト
INIT_WORK:
        ld      sp, WRKTOP + WRKSIZ     ; 初期化用の仮設定
        ld      hl, 0
        ld      b, WRKSIZ /2
INIT_WORK_1:
        push    hl
        djnz    INIT_WORK_1
        ; 0以外としたいワーク(たとえばTXTATR)が初期化されていないので注意
INIT_WORK_END:

        ld      sp, 0                   ; ずれたので再設定
        ld      hl, PARM40              ; CRTCをWIDTH40で初期化

        ; CRTCを初期化 (インライン展開済み)
        ; パラメータ
        ;   hl : 初期化パラメータの先頭アドレス
        ; レジスタ破壊 af bc hl
        ; 16バイト
INIT_CRT:
        ld      bc, IOCRTC
        ld      a, 13                   ; CRTCレジスタ番号
INIT_CRT_1:
        out     (c), a
        inc     c
        inc     b
        outi                            ; outiの仕様に注意
        dec     c
        dec     a
        jp      p, INIT_CRT_1
INIT_CRT_END:

        ; メインループ
IPL_LOOP:
        call    CLR_VRAM_ALL

        ld      a, 2                    ; 赤
        ld      (TXTATR), a
        ld      de, MSG_WELCOME
        call    IPLPRN_XY
        ld      a, 7                    ; 白
        ld      (TXTATR), a

        ld      de, MSG_WAITING
        call    IPLPRN_XY
        ld      a, (IPLDRV)
        add     a, 30h
        call    IPLPTC

        call    IS_FDD_READY            ; FDD 0の挿入チェック
        jr      nc, IPL_LOAD

        call    CLR_VRAM_TOP
        call    IPL_MENU                ; メニュー表示と入力待ち

        jr      IPL_LOOP
IPL_LOOP_END:

        ; ここに4バイトあき

        ; NMIリセットがアドレス066hとなるよう，調整する
        org     054h

        ; 読込みエラー等 (インライン展開済み)
        ; 12バイト
ERR_LOAD:
        ld      bc, 3000h+40*2          ; エラーステータス
        add     a, 20h
        out     (c), a
        ld      de, MSG_ERROR
        jr      ERR_MISSING_1
ERR_LOAD_END:

        ; 読み込むべきファイルが見つからないエラー (インライン展開済み)
        ; 6バイト
ERR_MISSING:
        ld      de, MSG_MISSING
ERR_MISSING_1:
        call    IPLPRN_XY
        ; ループの戻りをNMIリセットと共用

        ; NMIリセットのエントリ
RST_066H:
        jr      IPL_LOOP


; メニュー表示と選択
; 戻り値
;   (0ff87h) IPLDRV ドライブ指定(0～3)
; レジスタ破壊 af af' bc de hl
; 49バイト=表示17バイト+入力20バイト+データ12バイト
IPL_MENU:
        ld      hl, MSG_ADDR_MENU
        ld      a, 6                    ; メッセージの行数
IPL_MENU_1:
        ld      e, (hl)
        inc     hl
        ld      d, (hl)
        inc     hl
        ex      af, af'
        call    IPLPRN_XY
        ex      af, af'
        dec     a
        jr      nz, IPL_MENU_1

INP_MENU:
        call    IPLKEY
        sub     30h
        jp      m, INP_MENU
        cp      3
        jp      m, INP_MENU_1
        jr      INP_MENU

INP_MENU_1:
        ld      hl, IPLDRV
        ld      (hl), a
        ret


; ファイルの読込みと実行
IPL_LOAD:
        call    CLR_VRAM_TOP

        ld      de, MSG_LOOKING
        call    IPLPRN_XY
        ld      a, (IPLDRV)
        add     a, 30h
        call    IPLPTC

        call    LOAD1ST                 ; 先頭セクタの読込み
        jr      nz, ERR_LOAD            ; デバイスがおかしい？
        call    CHECK1ST                ; 起動フラグの確認
        jr      nz, ERR_MISSING         ; フラグ等がおかしい

        call    CLR_VRAM_TOP
        ld      hl, FILEBUF+11h         ; ファイル名の次，パスワード領域
        ld      (hl), 0                 ; 終端0にする。どうせパスワードをサポートしないので
        ld      de, MSG_LOADING
        call    IPLPRN_XY
        ld      de, FILEBUF+1
        call    IPLPRN

        ld      hl, (FILEBUF+12h)       ; プログラムサイズ(byte)
        dec     hl
        inc     h
        ld      a, h                    ; セクタ数(256で割っている)
        ld      hl, (FILEBUF+14h)       ; ロードアドレス
        ld      de, (FILEBUF+1eh)       ; 開始セクタ
        call    LOADFILE
        jr      nz, ERR_LOAD            ; デバイスがおかしい？

        ld      hl, (FILEBUF+16h)       ; 実行アドレス
        ld      bc, IOIPLOF
        out     (c), a                  ; aの値に依存しない
        jp      (hl)                    ; IPL終了


; 先頭セクタのチェック
; 戻り値
;   ゼロ : エラーでnz
CHECK1ST:
        ld      hl, FILEBUF
        ld      a, (hl)
        cp      1
        ret     nz
        ld      l, 0eh
        ld      a, (hl)
        cp      'S'
        ret     nz
        inc     hl
        ld      a, (hl)
        cp      'y'
        ret     nz
        inc     hl
        ld      a, (hl)
        cp      's'
        ret
CHECK1ST_END:


; ----------------------------------------------------------
; FDD関連ルーチン
; ----------------------------------------------------------

; ちょっと待つ
; 呼び出し元のcall命令含め 146clock = 36.5usec
; レジスタ破壊 af
; 6バイト
; call 17clock
WAIT1:  ld      a, 7                    ; 7clock
WAIT2:  dec     a                       ; 4clock
        jr      nz, WAIT2               ; 12clock
        ret                             ; 10clock


; FDDの準備確認
; パラメータ
;   (0ff87h) IPLDRV ドライブ指定(0～3)
; 戻り値
;   キャリ : 準備未完で1
; レジスタ破壊 af bc de
IS_FDD_READY:
        ld      a, (IPLDRV)
        or      80h
        ld      bc, IOFDCNO
        out     (c), a
        ld      c, LOW(IOFDCCR)

        ld      de, 0
IS_FDD_READY_1:
        in      a, (c)
        jp      p, IS_FDD_READY_2
        dec     de
        ld      a, d
        or      e
        jr      nz, IS_FDD_READY_1
        scf
        ret
IS_FDD_READY_2:
        and     a
        ret


; FDCのBusy待ち
; レジスタ破壊 af bc
WAIT_FDC_BUSY:
        ld      bc, IOFDCCR
        in      a, (c)
        and     81h
        jr      nz, WAIT_FDC_BUSY
        ret


; FDCリストア
; レジスタ破壊 af bc
FDC_RESTORE:
        ld      a, 2
        ld      bc, IOFDCCR
        out     (c), a
        call    WAIT_FDC_BUSY
        ret


; FDCシーク
; パラメータ
;   a : トラック番号
; レジスタ破壊 af bc
;   ゼロ : エラーでnz
FDC_SEEK:
        ld      bc, IOFDCDR
        out     (c), a
        ld      a, 1eh
        ld      bc, IOFDCCR
        out     (c), a
        call    WAIT_FDC_BUSY
        in      a, (c)
        and     99h
        ret


; 1セクタ読込み
; トラック移動は完了しているものとする
; パラメータ
;   a : セクタ番号(0オリジン)
;   hl : 読込みバッファのアドレス
; レジスタ破壊 af bc de hl
FDC_READ:
        ld      bc, IOFDCSR             ; セクタ番号のセット
        inc     a
        out     (c), a
        call    WAIT_FDC_BUSY

        ld      d, LOW(IOFDCCR)         ; FDCステータスレジスタ
        ld      e, LOW(IOFDCDR)         ; FDCデータレジスタ
        ld      bc, IOFDCCR

        ld      a, 80h
        out     (c), a                  ; 読出し指示
        call    WAIT1
FDC_READ_1:
        in      a,(c)                   ; ステータス確認
        rrca                            ; BUSY?
        jr      nc,FDC_READ_2
        rrca                            ; DATA REQUEST?
        jr      nc,FDC_READ_1

        ld      c, e                    ; FDCデータレジスタ
        in      a, (c)
        ld      (hl), a
        inc     hl
        ld      c, d                    ; FDCステータスレジスタ
        jr      FDC_READ_1

FDC_READ_2:
        rlca    ; BACK STAT (RRCA <-> RLCA)
        ret



; 先頭セクタの読込み
; 戻り値
;   ゼロ : エラーでnz
LOAD1ST:
        call    FDC_RESTORE
        ld      hl, FILEBUF
        ld      a, 0
        call    FDC_READ
        ret


; ファイルの読込み
; パラメータ
;   a : セクタ数
;   de : レコード番号(トラック+サイド+セクタ)
;   hl : 読込みバッファのアドレス
; レジスタ破壊 af bc de hl af'
LOADFILE:
        ex      af, af'                 ; aレジスタ退避

        ld      a, e

        ; d←トラック番号+サイド
        ; d = HIGH(de << 4)
        rlca
        rl      d
        rlca
        rl      d
        rlca
        rl      d
        rlca
        rl      d

        ; e←セクタ番号(0オリジン)
        ld      a, e
        and     0fh
        ld      e, a

LOADFILE_1:
        ; ドライブ番号とサイドを指定してモータON
        ld      a, 1
        and     d                       ; f←サイド
        ld      a, (IPLDRV)
        jr      z, LOADFILE_2           ; サイド0だった
        or      10h                     ; サイド1だった
LOADFILE_2
        or      80h                     ; モータON
        ld      bc, IOFDCNO
        out     (c), a

        ; トラックシーク
        ld      a, d
        srl     a
        call    FDC_SEEK                ; シーク
        ret     nz                      ; エラー

LOADFILE_3
        ; 1セクタ読込み
        push    de
        ld      a,e
        call    FDC_READ
        pop     de
        ret     nz                      ; エラー

        ; セクタ数確認
        ex      af, af'
        dec     a
        jr      z, LOADFILE_4           ; 読込み完了
        ex      af, af'

        ; セクタ番号++
        ld      a, e
        inc     a
        and     0fh
        ld      e, a
        jr      nz, LOADFILE_3          ; 次も同じトラック

        ; トラック番号++
        ld      a, d
        inc     a
        ld      d, a
        jr      LOADFILE_1

LOADFILE_4:
        ld      a, (IPLDRV)             ; モータOFF
        ld      bc, IOFDCNO
        out     (c), a

        ret
LOADFILE_END:


; アドレス 01bah
; ここに134バイトのあき


; ----------------------------------------------------------
; データ領域
; 計286バイト
; ----------------------------------------------------------
        org     0240h
DATA_TOP:

; メニューの表示内容
; 12バイト
MSG_ADDR_MENU:
        dw      MSG_MENU1
        dw      MSG_MENU2
        dw      MSG_MENU3
        dw      MSG_MENU4
        dw      MSG_MENU5
        dw      MSG_MENU6


; 表示メッセージ
; 合計 260バイト以下とする
; VRAMオフセット(2バイト), "メッセージ本体", 終端0
MSG_ERROR:
        dw      40
        db      "Device error"          ; 終端を次と共用
MSG_WAITING:
        dw      0
        db      "IPL is waiting for the device ready; FD"       ; 終端を次と共用
MSG_LOOKING:
        dw      0
        db      "IPL is looking for a program from FD"          ; 終端を次と共用
MSG_LOADING:
        dw      0
        db      "IPL is loading ",0
MSG_MISSING:
        dw      40
        db      "Program not found",0
MSG_MENU1:
        dw      9
        db      "Make Your device ready", 0
MSG_MENU2:
        dw      40*2+2
        db      "Press selected key to start driving:", 0
MSG_MENU3:
        dw      40*4+11
        db      "0-3:FDD", 0
MSG_MENU4:
        dw      40*5+13
        db      "R:ROM", 0
MSG_MENU5:
        dw      40*6+13
        db      "E:EMM", 0
MSG_MENU6:
        dw      40*7+13
        db      "M:Mon", 0
MSG_WELCOME:
        dw      40*23+8
        db      "X1 compatible IPL 0.2.0", 0


; WIDTH40とWIDTH80のCRTC初期化パラメータ
; レジスタR13から逆順にR0まで
; 14バイト
PARM40: db      0, 0, 0, 0, 7, 0, 28, 25, 2, 31, 52, 45, 40, 55
;PARM80: db      0, 0, 0, 0, 7, 0, 28, 25, 2, 31, 56, 89, 80, 111

DATA_END:


; ここに5バイトあき


; ----------------------------------------------------------
; テキスト関係ルーチン
; ----------------------------------------------------------
; 先頭アドレスをIPLKEYのアドレスから逆算
        org     035eh

; テキストVRAMクリア(全画面) (アドレス変えてもよい)
; レジスタ破壊 af bc hl
; 7バイト
CLR_VRAM_ALL:
        ld      a, HIGH(TXTSIZ)
        ld      hl, TEXT_STD
        jr      CLR_VRAM


; テキストVRAMクリア(上部3行+αだけ) (アドレス変えてもよい)
; レジスタ破壊 af bc hl
; 5バイト
CLR_VRAM_TOP:
        ld      a, 1
        ld      hl, TEXT_STD
        ;jr      CLR_VRAM               ; 次のルーチンなので省略


; テキストVRAMクリア(レジスタ指定) (アドレス変えてもよい)
; パラメータ
;   a : 埋めるバイト数 / 256
;   h : 埋めるキャラクタコード(通常 20h)
;   l : 埋めるアトリビュート(通常 7h)
; レジスタ破壊 af bc hl
; 22バイト
CLR_VRAM:
        ld      bc, IOTEXT
CLR_VRAM_1:                             ; テキストを256バイト分クリア
        out     (c), h
        inc     c
        jr      nz, CLR_VRAM_1
        res     BIT_ATTR_TEXT, b        ; アトリビュートアドレスに変換
                                        ; 例えば 30aah → 20aah
CLR_VRAM_2:                             ; アトリビュートを256バイト分クリア
        out     (c), l
        inc     c
        jr      nz, CLR_VRAM_2
        set     BIT_ATTR_TEXT, b        ; テキストアドレスに変換
        inc     b
        dec     a
        jr      nz, CLR_VRAM_1          ; 256*aバイト分のループ
        ret


; 80C49(サブCPU)の書込み可能待ち (アドレス変えてもよい)
; レジスタ破壊 af bc
; 10バイト
WAIT_80C49_WR:
        ld      bc, IO8255B
WAIT_80C49_WR_1:
        in      a, (c)
        and     40h
        jr      nz, WAIT_80C49_WR_1
        ret


; IPL用KEY入力 (アドレス固定)
; 戻り値
;   a : KEYコード
; レジスタ破壊 af
        org     038ah
IPLKEY:
        push    bc

        ei                              ; サブCPUとの通信時に必要？
        call    WAIT_80C49_WR
        ld      bc, IO80C49
        ld      a, 0e6h                 ; e6=キー入力
        out     (c), a
        call    WAIT_80C49_WR
        di

        call    READ_80C49              ; a←ファンクションキー(読み捨て)
        call    READ_80C49              ; a←ASCII

        pop     bc
        ret


; 80C49(サブCPU)の読出し
; 読出し可能を待ってから1バイト読む
; レジスタ破壊 af bc
; 15バイト
READ_80C49:
        ld      bc, IO8255B
READ_80C49_1:
        in      a, (c)
        and     20h
        jr      nz, READ_80C49_1

        ld      bc, IO80C49
        in      a, (c)
        ret


; アドレス 03b1h
; ここに1バイトあき
        nop


; IPL用メッセージ表示(座標指定)
; パラメータ
;   de : 表示位置とメッセージのアドレス(00終端)
;   (0ff86h) TXTATR アトリビュート
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 af de
; 12バイト
IPLPRN_XY:
        push    bc                      ; 最後にpop bcされてしまうので
        ex      de, hl
        ld      c, (hl)
        inc     hl
        ld      b, (hl)
        inc     hl
        ex      de, hl

        call    LD_TEXT_ADDR_1
        jr      IPLPRN_1                ; 飛び先でret


; IPL用1文字表示(レジスタ破壊)
; パラメータ
;   a : 文字コード
;   bc : VRAMアドレス
;   (0ff86h) TXTATR アトリビュート
; 戻り値
;   bc : VRAMアドレス
; レジスタ破壊 af bc
; 13バイト
IPL_PUTCHAR:
        out     (c), a
        res     BIT_ATTR_TEXT, b        ; アトリビュートアドレスに変換
                                        ; 例えば 30aah → 20aah
        ld      a, (TXTATR)
        out     (c), a
        set     BIT_ATTR_TEXT, b        ; テキストアドレスに変換
        inc     bc
        ret


; IPL用メッセージ表示 (アドレス固定)
; パラメータ
;   de : メッセージのアドレス(00終端)
;   (0ff80h) TXTCUR カーソルxy
;   (0ff86h) TXTATR アトリビュート
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 de
org     03cbh
IPLPRN:
        push    bc
        call    LD_TEXT_ADDR
IPLPRN_1
        ld      a, (de)
        or      a
        jr      z, IPLPTC_END           ; メモリ足りないので後処理を共用している
        call    IPL_PUTCHAR
        inc     de
        jr      IPLPRN_1


; IPL用1文字表示 (アドレス固定)
; パラメータ
;   a : 文字コード
;   (0ff80h) TXTCUR カーソルxy
;   (0ff86h) TXTATR アトリビュート
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 なし
; 15バイト
org     03d9h
IPLPTC:
        push    af
        call    IPLPTC_1
        pop     af
        ret
IPLPTC_1:
        push    bc
        push    af
        call    LD_TEXT_ADDR
        pop     af
        call    IPL_PUTCHAR

; IPL用1文字表示の後処理
; IPLPTCとIPLPRNで共用している
; 5バイト
IPLPTC_END:
        call    ST_CUR_ADDR
        pop     bc
        ret

; アドレス 03edh
; 残り19バイト

; 表示アドレス計算
; パラメータ
;   (0ff80h) TXTCUR カーソルxy
; 戻り値
;   bc : VRAMアドレス
; レジスタ破壊 af bc
; 9バイト
LD_TEXT_ADDR:
        ld      bc, (TXTCUR)
LD_TEXT_ADDR_1:
        ld      a, HIGH(IOTEXT)
        add     a, b
        ld      b, a
        ret


; カーソルアドレス計算
; パラメータ
;   bc : VRAMアドレス
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 af bc
; 9バイト
ST_CUR_ADDR:
        ld      a, -(HIGH(IOTEXT))
        add     a, b
        ld      b, a
        ld      (TXTCUR), bc
        ret


; ここに1バイトあき
