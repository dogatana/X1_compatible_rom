;
; X1 compatible IPL
;
; programed by NAKAUE,T
;
; These codes are licensed under CC0.
; http://creativecommons.org/publicdomain/zero/1.0/deed.ja
;
; 2020-07-31 ver0.1.0 first version
;                     武田君のエミュレータでS-OS SWORDを起動できた
;                     バイナリサイズ 950byte，未実装機能があるのに大きい
; 2020-08-01 ver0.2.0 リファクタリング
;                     ディスク関係以外のアドレスをオリジナルと合わせた
;                     連続空きメモリ134バイト
; 2020-08-03 ver0.3.0 ディスク関係並べ替え
;                     IPL ROMからRAMへの切り替えをRAM上で行うようにした
;                     起動時にWIDTH40にする処理で，8255への出力を追加
;                     連続空きメモリ118バイト
; 2020-08-04 ver0.3.1 ディスク関係リファクタリングとデバッグ
;                     ファイルバッファの位置を直し忘れていた
;                     ファイルバッファが60K CP/Mに潰されるので対策
;
; かつて X1エミュの部屋(http://www.turboz.to/)に掲載されていた
; ぷにゅ氏作の IPL ver1.01(x1ipl101.zip,IPLROM.z80)を参考にしている
;
; その他の参考文献
; X1 turbo  BIOSの解析,稲葉 康治,Oh!MZ 1985年1月号,p.97～109
; IOCS DATA LIST,泉 大介ら,Oh!MZ 1986年11月号,p.76～
; 試験に出るX1,祝 一平，日本ソフトバンク,1987
; HuBASIC Format詳細,BouKiCHi,https://boukichi.github.io/HuDisk/HuBASIC_Format.html
;   2020-07-31 閲覧

; FDD0-3からの起動のみ実装する
; CMT，Timer関係を実装しない
; ROMとEMMの実装を保留

; 以下のエントリを固定番地とする
; 0066h : NMIリセット(ok)
; 00f5h : IPLエラー処理?(未実装)
; (01cfh : IPL overlay? x1ipl101で固定アドレスとしているが，不要？)
; 021ah : IPL用ディスクREAD
; 038ah : IPL用KEY入力(ok)
; 03cbh : IPL用メッセージ表示(ok)
; 03d9h : IPL用1文字表示ルーチン(ok)
;
; 以下のバッファを固定番地とする
; 0ff80h : カーソルxy
; 0ff86h : テキスト色
; 0ff87h : ドライブ番号

; ワークエリアアドレス

WRKTOP  equ     0ff70h                  ; ワークエリアの先頭アドレス
TXTCUR  equ     WRKTOP + 10h
TXTATR  equ     WRKTOP + 16h
IPLDRV  equ     WRKTOP + 17h
WRKSIZ  equ     20h                     ; ワークエリアの長さ

REDIREC equ     WRKTOP + 0h             ; IPL ROMからRAMに切り替えるリダイレクタ
EXECADR equ     REDIREC + 3             ; 実行アドレス

FILEBUF equ     0fe00h                  ; ファイル読込みバッファ


; 以下はturbo BIOSで使用
COLORF  equ     0f8d0h
CLSCHR  equ     0f8d1h

; IOアドレス
IOFDCCR equ     0ff8h                   ; FDC コマンドレジスタ
IOFDCTR equ     0ff9h                   ; FDC トラックレジスタ
IOFDCSR equ     0ffah                   ; FDC セクタレジスタ
IOFDCDR equ     0ffbh                   ; FDC データレジスタ
IOFDCNO equ     0ffch                   ; ドライブNo./サイド/モーターON
IOCRTC  equ     1800h                   ; CRTC レジスタ
IO80C49 equ     1900h                   ; サブCPU
IO8255B equ     1a01h                   ; 8255 port B
IO8255C equ     1a02h                   ; 8255 port C
IOIPLOF equ     1e00h                   ; IPL ROM OFF
IOATTR  equ     2000h                   ; アトリビュートVRAM
IOTEXT  equ     3000h                   ; テキストVRAM
TXTSIZ  equ     800h                    ; テキストVRAMのサイズ

; IOATTRとIOTEXTで異なるビット位置
; log2((IOATTR ^ IOTEXT) >> 8)
BIT_ATTR_TEXT   equ     4

; テキストクリアの標準色
TEXT_STD        equ     2007h           ; 20=SPC,07=白


        org     00000h

; ----------------------------------------------------------
; メインルーチンとメニュー
; ----------------------------------------------------------

; IPL起動
IPLBOT:

        ; ワークエリアの初期化 (インライン展開済み)
        ; 12バイト
INIT_WORK:
        ld      sp, WRKTOP + WRKSIZ     ; 初期化用の仮設定
        ld      hl, 0
        ld      b, WRKSIZ /2
INIT_WORK_1:
        push    hl
        djnz    INIT_WORK_1
        ; 0以外としたいワーク(たとえばTXTATR)が初期化されていないので注意
INIT_WORK_END:

        ld      sp, 0                   ; ずれたので再設定
        ld      hl, PARM40              ; CRTCをWIDTH40で初期化

        ; CRTCを初期化 (インライン展開済み)
        ; パラメータ
        ;   hl : 初期化パラメータの先頭アドレス
        ; レジスタ破壊 af bc hl
        ; 16バイト
INIT_CRT:
        ld      bc, IOCRTC
        ld      a, 13                   ; CRTCレジスタ番号
INIT_CRT_1:
        out     (c), a
        inc     c
        inc     b
        outi                            ; outiの仕様に注意
        dec     c
        dec     a
        jp      p, INIT_CRT_1

        ld      bc, IO8255C
        ld      a, 40h
        out     (c), a
INIT_CRT_END:

        ; メインループ
IPL_LOOP:
        call    CLR_VRAM_ALL

        ld      a, 2                    ; 赤
        ld      (TXTATR), a
        ld      de, MSG_WELCOME
        call    IPLPRN_XY
        ld      a, 7                    ; 白
        ld      (TXTATR), a

        ld      de, MSG_WAITING
        call    IPLPRN_XY
        call    PRT_DRV

        call    IS_FDD_READY            ; FDD 0の挿入チェック
        jr      nc, IPL_LOAD

IPL_LOOP2:
        call    IPL_MENU                ; メニュー表示と入力待ち

        jr      IPL_LOOP
IPL_LOOP_END:

        ; ここに3バイトあき

        ; NMIリセットがアドレス066hとなるよう，調整する
        org     051h

        ; 読込みエラー等 (インライン展開済み)
        ; 12バイト
ERR_LOAD:
        ld      bc, 3000h+40*2          ; エラーステータス
        add     a, 20h
        out     (c), a
        ld      de, MSG_ERROR
        jr      ERR_MISSING_1
ERR_LOAD_END:

        ; 読み込むべきファイルが見つからないエラー (インライン展開済み)
        ; 9バイト
ERR_MISSING:
        ld      de, MSG_MISSING
ERR_MISSING_1:
        call    IPLPRN_XY
        call    WAIT_MOMENT
        ; ループの戻りをNMIリセットと共用

        ; NMIリセットのエントリ(メニューに戻す)
RST_066H:
        jr      IPL_LOOP2


; ドライブ番号の表示
; パラメータ
;   (0ff80h) TXTCUR カーソルxy
;   (0ff86h) TXTATR アトリビュート
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 a
; 8バイト
PRT_DRV:
        ld      a, (IPLDRV)
        add     a, 30h
        jp      IPLPTC                  ; 飛び先でリターン


; 数秒待つ
; レジスタ破壊 af bc de
; 13バイト
WAIT_MOMENT:
        ld      b, 10
        ld      de, 0
WAIT_MOMENT_1:
        dec     de
        ld      a, d
        or      e
        jr      nz, WAIT_MOMENT_1
        djnz    WAIT_MOMENT_1
        ret


; メニュー表示と選択
; 戻り値
;   (0ff87h) IPLDRV ドライブ指定(0～3)
; レジスタ破壊 af af' bc de hl
; 40バイト=表示20バイト+入力20バイト (他にデータ14バイト)
IPL_MENU:
        call    CLR_VRAM_TOP
        ld      hl, MSG_ADDR_MENU
        ld      a, 7                    ; メッセージの行数
IPL_MENU_1:
        ld      e, (hl)
        inc     hl
        ld      d, (hl)
        inc     hl
        ex      af, af'
        call    IPLPRN_XY
        ex      af, af'
        dec     a
        jr      nz, IPL_MENU_1

INP_MENU:
        call    IPLKEY
        sub     30h
        jp      m, INP_MENU
        cp      3
        jp      m, INP_MENU_1
        jr      INP_MENU

INP_MENU_1:
        ld      hl, IPLDRV
        ld      (hl), a
        ret


; ファイルの読込みと実行
; 79バイト
IPL_LOAD:
        call    CLR_VRAM_TOP

        ld      de, MSG_LOOKING
        call    IPLPRN_XY
        call    PRT_DRV

        call    LOAD1ST                 ; 先頭セクタの読込み
        jr      nz, ERR_LOAD            ; デバイスがおかしい？
        call    CHECK1ST                ; 起動フラグの確認
        jr      nz, ERR_MISSING         ; フラグ等がおかしい


        ; リダイレクタをRAMに書き込む
        ; 実行アドレスを退避しておかないとCP/Mにバッファを潰される
        ld      hl, REDIREC
        ld      (hl), 0edh              ; out (c), a
        inc     hl
        ld      (hl), 79h
        inc     hl
        ld      (hl), 0c3h              ; jp xxxx
        ld      hl, (FILEBUF+16h)       ; 実行アドレス
        ld      (EXECADR), hl

        ; ファイル本体の読込み
        call    CLR_VRAM_TOP
        ld      de, MSG_LOADING
        call    IPLPRN_XY
        ld      de, FILEBUF+1
        call    IPLPRN

        ld      hl, (FILEBUF+12h)       ; プログラムサイズ(byte)
        dec     hl
        inc     h
        ld      a, h                    ; セクタ数(256で割っている)
        ld      hl, (FILEBUF+14h)       ; ロードアドレス
        ld      de, (FILEBUF+1eh)       ; 開始セクタ
        call    LOADFILE
        jp      nz, ERR_LOAD            ; デバイスがおかしい？

        ld      bc, IOIPLOF
        jp      REDIREC                 ; IPL終了
IPL_LOAD_END:


; 先頭セクタのチェック
; パスワード領域を0にし，ファイル名の文字列を0終端にする
; 戻り値
;   ゼロ : エラーでnz
; レジスタ破壊 af hl
; 26バイト
CHECK1ST:
        ld      hl, FILEBUF
        ld      a, (hl)
        dec     a
        ret     nz
        ld      l, 0eh
        ld      a, (hl)
        cp      'S'
        ret     nz
        inc     hl
        ld      a, (hl)
        cp      'y'
        ret     nz
        inc     hl
        ld      a, (hl)
        cp      's'
        ret     nz
        inc     hl                      ; ファイル名の次，パスワード領域
                                        ; フラグ変化しないのがありがたい
        ld      (hl), 0                 ; パスワード領域をつぶし，文字列の終端0にする
                                        ; どうせパスワードをサポートしないので問題なし
        ret
CHECK1ST_END:


; ----------------------------------------------------------
; FDD関連ルーチン その1
; ----------------------------------------------------------

; FDDの準備確認
; パラメータ
;   (0ff87h) IPLDRV ドライブ指定(0～3)
; 戻り値
;   キャリ : 準備未完で1
; レジスタ破壊 af bc de
; 29バイト
IS_FDD_READY:
        ld      a, (IPLDRV)
        or      80h
        ld      bc, IOFDCNO
        out     (c), a
        ld      c, LOW(IOFDCCR)

        ld      de, 0
IS_FDD_READY_1:
        in      a, (c)
        jp      p, IS_FDD_READY_2
        dec     de
        ld      a, d
        or      e
        jr      nz, IS_FDD_READY_1
        scf
        ret
IS_FDD_READY_2:
        and     a
        ret


; FDCリストア
; レジスタ破壊 af bc
; 2バイト
FDC_RESTORE:
        ld      a, 2
        ; 次のルーチン(FDC_CMD)へ続く


; FDCのコマンドレジスタに命令を与え，完了を待つ
; パラメータ
;   a : コマンド番号
; レジスタ破壊 af bc
; 5バイト
FDC_CMD:
        ld      bc, IOFDCCR
        out     (c), a
        ; 次のルーチン(FDC_RESTORE)へ続く


; FDCのBusy待ち
; bcレジスタがIOFDCCRでなければならない
; bレジスタが0fh(FDCのIOアドレスの上位)でなければならない
; レジスタ破壊 af bc
; 7バイト
WAIT_FDC_BUSY:
WAIT_FDC_BUSY_1:
        in      a, (c)
        and     81h
        jr      nz, WAIT_FDC_BUSY_1
        ret


; FDCシーク
; パラメータ
;   a : トラック番号
; レジスタ破壊 af bc
;   ゼロ : エラーでnz
; 15バイト
FDC_SEEK:
        ld      bc, IOFDCDR
        out     (c), a
        ld      a, 1eh
        call    FDC_CMD
        in      a, (c)
        and     99h
        ret


; 先頭セクタの読込み
; 戻り値
;   ゼロ : エラーでnz
; 7バイト
LOAD1ST:
        call    FDC_RESTORE
        ld      hl, FILEBUF
        xor     a
        ; 次のルーチン(FDC_READ)へ続く


; 1セクタ読込み
; トラック移動は完了しているものとする
; パラメータ
;   a : セクタ番号(0オリジン)
;   hl : 読込みバッファのアドレス
; レジスタ破壊 af bc de hl
; 41バイト
FDC_READ:
        ld      bc, IOFDCSR             ; セクタ番号のセット
        inc     a
        out     (c), a
        ld      c, LOW(IOFDCCR)
        call    WAIT_FDC_BUSY

        ld      d, LOW(IOFDCCR)         ; FDCステータスレジスタ
        ld      e, LOW(IOFDCDR)         ; FDCデータレジスタ
        ld      bc, IOFDCCR

        ld      a, 80h
        out     (c), a                  ; 読出し指示
        call    WAIT1
FDC_READ_1:
        in      a,(c)                   ; ステータス確認
        rrca                            ; BUSY?
        jr      nc,FDC_READ_2
        rrca                            ; DATA REQUEST?
        jr      nc,FDC_READ_1

        ld      c, e                    ; FDCデータレジスタ
        in      a, (c)
        ld      (hl), a
        inc     hl
        ld      c, d                    ; FDCステータスレジスタ
        jr      FDC_READ_1

FDC_READ_2:
        rlca    ; BACK STAT (RRCA <-> RLCA)
        ret
FDC_READ_END:


; アドレス 17ah
; ここに114バイトのあき


; ----------------------------------------------------------
; FDD関連ルーチン その2
; ----------------------------------------------------------

; アドレスはLOADFILEのエントリアドレスから逆算
        org     01ech

; ちょっと待つ
; 呼び出し元のcall命令含め 146clock = 36.5usec
; レジスタ破壊 af
; 6バイト
; call 17clock
WAIT1:  ld      a, 7                    ; 7clock
WAIT2:  dec     a                       ; 4clock
        jr      nz, WAIT2               ; 12clock
        ret                             ; 10clock


; ファイルの読込み(本体)
; エントリアドレスを固定する関係で，後半がここに飛んでいる
; 40バイト
LOADFILE_MAIN:
        ; トラックシーク
        ld      a, d
        srl     a
        call    FDC_SEEK                ; シーク
        ret     nz                      ; エラー

LOADFILE_3:
        ; 1セクタ読込み
        push    de
        ld      a,e
        call    FDC_READ
        pop     de
        ret     nz                      ; エラー

        ; セクタ数確認
        ex      af, af'
        dec     a
        jr      z, LOADFILE_4           ; 読込み完了
        ex      af, af'

        ; セクタ番号++
        ld      a, e
        inc     a
        and     0fh
        ld      e, a
        jr      nz, LOADFILE_3          ; 次も同じトラック

        ; トラック番号++
        ld      a, d
        inc     a
        ld      d, a
        jr      LOADFILE_1

LOADFILE_4:
        ld      a, (IPLDRV)             ; モータOFF
        ld      bc, IOFDCNO
        out     (c), a

        ret
LOADFILE_MAIN_END:


; ファイルの読込み(アドレス固定)
; パラメータ
;   a : セクタ数
;   de : レコード番号(トラック+サイド+セクタ)
;   hl : 読込みバッファのアドレス
; レジスタ破壊 af bc de hl af'
; 37バイト
        org 021ah
LOADFILE:
        ex      af, af'                 ; aレジスタ退避

        ld      a, e

        ; d←トラック番号+サイド
        ; d = HIGH(de << 4)
        rlca
        rl      d
        rlca
        rl      d
        rlca
        rl      d
        rlca
        rl      d

        ; e←セクタ番号(0オリジン)
        ld      a, e
        and     0fh
        ld      e, a

LOADFILE_1:
        ; ドライブ番号とサイドを指定してモータON
        ld      a, 1
        and     d                       ; f←サイド
        ld      a, (IPLDRV)
        jr      z, LOADFILE_2           ; サイド0だった
        or      10h                     ; サイド1だった
LOADFILE_2:
        or      80h                     ; モータON
        ld      bc, IOFDCNO
        out     (c), a

        jr      LOADFILE_MAIN

LOADFILE_END:

; ここに1バイトあき

; ----------------------------------------------------------
; データ領域
; 計286バイト
; ----------------------------------------------------------
        org     0240h
DATA_TOP:

; メニューの表示内容
; 12バイト
MSG_ADDR_MENU:
        dw      MSG_MENU1
        dw      MSG_MENU2
        dw      MSG_MENU3
        dw      MSG_MENU4
        dw      MSG_MENU5
        dw      MSG_MENU6
        dw      MSG_MENU7


; 表示メッセージ
; 合計 260バイト以下とする
; VRAMオフセット(2バイト), "メッセージ本体", 終端0
MSG_ERROR:
        dw      40
        db      "Device error"          ; 終端を次と共用
MSG_WAITING:
        dw      0
        db      "IPL is waiting for the device FD"              ; 終端を次と共用
MSG_LOOKING:
        dw      0
        db      "IPL is looking for a program from FD"          ; 終端を次と共用
MSG_LOADING:
        dw      0
        db      "IPL is loading ",0
MSG_MISSING:
        dw      40
        db      "Program not found",0
MSG_MENU1:
        dw      9
        db      "Make Your device ready", 0
MSG_MENU2:
        dw      40*2+2
        db      "Press selected key to start driving:", 0
MSG_MENU3:
        dw      40*4+11
        db      "0-3:FDD", 0
MSG_MENU4:
        dw      40*5+13
        db      "R:ROM", 0
MSG_MENU5:
        dw      40*6+13
        db      "E:EMM", 0
MSG_MENU6:
        dw      40*7+13
        db      "M:Mon", 0
MSG_MENU7:
        dw      40*8+13
        db      "#:RAM", 0
MSG_WELCOME:
        dw      40*23+8
        db      "X1 compatible IPL 0.3.1", 0


; WIDTH40とWIDTH80のCRTC初期化パラメータ
; レジスタR13から逆順にR0まで
; 14バイト
PARM40: db      0, 0, 0, 0, 7, 0, 28, 25, 2, 31, 52, 45, 40, 55
;PARM80: db      0, 0, 0, 0, 7, 0, 28, 25, 2, 31, 56, 89, 80, 111

DATA_END:

; ここに2バイトあき

; ----------------------------------------------------------
; テキスト関係ルーチン
; ----------------------------------------------------------
; 先頭アドレスをIPLKEYのアドレスから逆算
        org     035eh

; テキストVRAMクリア(全画面) (アドレス変えてもよい)
; レジスタ破壊 af bc hl
; 7バイト
CLR_VRAM_ALL:
        ld      a, HIGH(TXTSIZ)
        ld      hl, TEXT_STD
        jr      CLR_VRAM


; テキストVRAMクリア(上部3行+αだけ) (アドレス変えてもよい)
; レジスタ破壊 af bc hl
; 5バイト
CLR_VRAM_TOP:
        ld      a, 1
        ld      hl, TEXT_STD
        ;jr      CLR_VRAM               ; 次のルーチンなので省略


; テキストVRAMクリア(レジスタ指定) (アドレス変えてもよい)
; パラメータ
;   a : 埋めるバイト数 / 256
;   h : 埋めるキャラクタコード(通常 20h)
;   l : 埋めるアトリビュート(通常 7h)
; レジスタ破壊 af bc hl
; 22バイト
CLR_VRAM:
        ld      bc, IOTEXT
CLR_VRAM_1:                             ; テキストを256バイト分クリア
        out     (c), h
        inc     c
        jr      nz, CLR_VRAM_1
        res     BIT_ATTR_TEXT, b        ; アトリビュートアドレスに変換
                                        ; 例えば 30aah → 20aah
CLR_VRAM_2:                             ; アトリビュートを256バイト分クリア
        out     (c), l
        inc     c
        jr      nz, CLR_VRAM_2
        set     BIT_ATTR_TEXT, b        ; テキストアドレスに変換
        inc     b
        dec     a
        jr      nz, CLR_VRAM_1          ; 256*aバイト分のループ
        ret


; 80C49(サブCPU)の書込み可能待ち (アドレス変えてもよい)
; レジスタ破壊 af bc
; 10バイト
WAIT_80C49_WR:
        ld      bc, IO8255B
WAIT_80C49_WR_1:
        in      a, (c)
        and     40h
        jr      nz, WAIT_80C49_WR_1
        ret


; IPL用KEY入力 (アドレス固定)
; 戻り値
;   a : KEYコード
; レジスタ破壊 af
        org     038ah
IPLKEY:
        push    bc

        ei                              ; サブCPUとの通信時に必要？
        call    WAIT_80C49_WR
        ld      bc, IO80C49
        ld      a, 0e6h                 ; e6=キー入力
        out     (c), a
        call    WAIT_80C49_WR
        di

        call    READ_80C49              ; a←ファンクションキー(読み捨て)
        call    READ_80C49              ; a←ASCII

        pop     bc
        ret


; 80C49(サブCPU)の読出し
; 読出し可能を待ってから1バイト読む
; レジスタ破壊 af bc
; 15バイト
READ_80C49:
        ld      bc, IO8255B
READ_80C49_1:
        in      a, (c)
        and     20h
        jr      nz, READ_80C49_1

        ld      bc, IO80C49
        in      a, (c)
        ret


; アドレス 03b1h
; ここに1バイトあき
        nop


; IPL用メッセージ表示(座標指定)
; パラメータ
;   de : 表示位置とメッセージのアドレス(00終端)
;   (0ff86h) TXTATR アトリビュート
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 af de
; 12バイト
IPLPRN_XY:
        push    bc                      ; 最後にpop bcされてしまうので
        ex      de, hl
        ld      c, (hl)
        inc     hl
        ld      b, (hl)
        inc     hl
        ex      de, hl

        call    LD_TEXT_ADDR_1
        jr      IPLPRN_1                ; 飛び先でret


; IPL用1文字表示(レジスタ破壊)
; パラメータ
;   a : 文字コード
;   bc : VRAMアドレス
;   (0ff86h) TXTATR アトリビュート
; 戻り値
;   bc : VRAMアドレス
; レジスタ破壊 af bc
; 13バイト
IPL_PUTCHAR:
        out     (c), a
        res     BIT_ATTR_TEXT, b        ; アトリビュートアドレスに変換
                                        ; 例えば 30aah → 20aah
        ld      a, (TXTATR)
        out     (c), a
        set     BIT_ATTR_TEXT, b        ; テキストアドレスに変換
        inc     bc
        ret


; IPL用メッセージ表示 (アドレス固定)
; パラメータ
;   de : メッセージのアドレス(00終端)
;   (0ff80h) TXTCUR カーソルxy
;   (0ff86h) TXTATR アトリビュート
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 de
org     03cbh
IPLPRN:
        push    bc
        call    LD_TEXT_ADDR
IPLPRN_1
        ld      a, (de)
        or      a
        jr      z, IPLPTC_END           ; メモリ足りないので後処理を共用している
        call    IPL_PUTCHAR
        inc     de
        jr      IPLPRN_1


; IPL用1文字表示 (アドレス固定)
; パラメータ
;   a : 文字コード
;   (0ff80h) TXTCUR カーソルxy
;   (0ff86h) TXTATR アトリビュート
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 なし
; 15バイト
org     03d9h
IPLPTC:
        push    af
        call    IPLPTC_1
        pop     af
        ret
IPLPTC_1:
        push    bc
        push    af
        call    LD_TEXT_ADDR
        pop     af
        call    IPL_PUTCHAR

; IPL用1文字表示の後処理
; IPLPTCとIPLPRNで共用している
; 5バイト
IPLPTC_END:
        call    ST_CUR_ADDR
        pop     bc
        ret

; アドレス 03edh
; 残り19バイト

; 表示アドレス計算
; パラメータ
;   (0ff80h) TXTCUR カーソルxy
; 戻り値
;   bc : VRAMアドレス
; レジスタ破壊 af bc
; 9バイト
LD_TEXT_ADDR:
        ld      bc, (TXTCUR)
LD_TEXT_ADDR_1:
        ld      a, HIGH(IOTEXT)
        add     a, b
        ld      b, a
        ret


; カーソルアドレス計算
; パラメータ
;   bc : VRAMアドレス
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 af bc
; 9バイト
ST_CUR_ADDR:
        ld      a, -(HIGH(IOTEXT))
        add     a, b
        ld      b, a
        ld      (TXTCUR), bc
        ret


; ここに1バイトあき
